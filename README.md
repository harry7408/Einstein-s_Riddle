# Einstein-s_Riddle
## 아인슈타인의 수수께끼 문제

아인슈타인의 퍼즐(얼룩말 퍼즐)
 	- 아인슈타인이 어린 시절에 만들었다고 알려진 퍼즐이며 전 세계 인구의 2%만이 풀 수 있을 것이라 단언한 문제

- 문제
	Precondition : 각 국적의 사람들이 키우는 동물, 피우는 담배, 마시는 음료는 모두 다르고 사는 집의 색상도 달라야 한다.
 (색상, 국적, 음료, 담배, 애완동물을 속성이라고 지칭하겠다)
  문제를 해결하기 위한 15가지 조건
	
  1. 영국인은 빨간 집에 산다.
	2. 스웨덴 사람은 개를 기른다.
	3. 덴마크 사람은 차를 마신다.
	4. 초록색 집은 흰색 집 왼쪽에 있다.
	5. 초록색 집에 사는 사람은 커피를 마신다.
	6. 폴말 담배를 피우는 사람은 새를 기른다.
	7. 노란색 집에 사는 사람은 던힐을 피운다.
	8. 가운데 집에 사는 사람은 우유를 마신다.
	9. 노르웨이 사람은 첫 번째 집에 산다.
	10. 블랜드 담배를 피우는 사람은 고양이 기르는 사람 옆집에 산다.
	11. 말을 키우는 사람은 던힐 피우는 사람 옆집에 산다.
	12. 블루 마스터 담배를 피우는 사람은 맥주를 마신다.
	13. 독일인은 프린스 담배를 피운다.
	14. 노르웨이 사람은 파란색 집 옆에 산다.
	15. 블랜드 담배를 피우는 사람은 물 마시는 사람의 이웃이다.

- 문제 접근 방식
	<br>집과 각 조건의 속성들을 2차원 배열의 행, 열로 나열하면 조건에 맞는 위치에 속성의 값을 넣어야 하는 문제로 생각해 볼 수 있다.</br>
 <br>각 속성의 값을 나열하는 것이므로 이를 순열 문제와 같은 방법으로 접근해 보았다.</br>
	<br>만약 15가지 조건을 작성한 Promising 함수를 통해 하나하나 비교한다면 모든 경우를 탐색해야 한다. 각 배열은 길이가 5이므로 5개의 수를 나열하는 방법은 5! 가지가 있는데 각 속성이 5가지가 있으므로 상당히 오랜 시간이 걸리게 된다. (n!과 a^n의 시간복잡도는 상당히 큰 편인데 이를 제곱수와 지수로 사용하기 때문)
	만약 조건을 만족하면 더 탐색하고 아니면 더 탐색하지 않는 Backtracking 기법 가운데 하나인 Depth First Search를 이용하면 탐색하는 수를 상당히 줄일 수 있다. (5가지 속성을 depth로 사용)</br> 
	<br>문제 조건 중 9번 조건은 정확한 정보를 주기 때문에 표를 채울 때 가장 먼저 사용되는 조건이다. 이에 국적 정보에서 첫 번째 집에 노르웨이 사람이 살지 않는 경우는 더 탐색할 필요가 없도록 국적 정보를 첫 번째로 두고 14번 정보를 통해 파란색 집은 두 번째 위치한 집인 것을 알 수 있고 4, 5, 8번 조건을 이용하여 4, 5번째 집이 각각 초록색, 흰색이라는 것을 알 수 있다. 위와 같은 과정을 색상=>음료->담배->애완동물 순서로 depth를 정하고 Promising 조건을 점검하도록 하였다.</br> <br>
  
  <p allign="center"><img src="https://user-images.githubusercontent.com/84065395/217197454-b6627510-a10d-450f-ada5-927b69b5f125.png"></p>


이를 상태 공간 트리로 표현해 본다면 아래의 그림과 같다.
  <p allign="center"><img src="https://user-images.githubusercontent.com/84065395/217198291-7ddebe3a-9f93-40a5-acf4-bc0c75c04e91.png"></p>


<br>수수께끼를 탐색하는 과정은 각 속성에 해당하는 행에서 속성값 들의 위치를 재귀적으로 바꿔가며 끝 원소까지 바꿨을 때 Promising 함수를 호출하여 만족하는 경우 다음 depth로 넘어가도록 작성하였다. </br>
<br>
끝까지 원소들을 비교해가며 5번째까지 들어가면 Promising 함수로 점검 후 다음 깊이로 갈지 말지 정하게 된다</br>
	<br>각 속성의 값은 다루기 편하고 이름을 통해 의미를 파악하기 위해 열거형을 통해 선언해 주었고 가장 끝 깊이에 도달하면 결과를 출력하도록 하였다. (1차원 배열 안에서 나열)
